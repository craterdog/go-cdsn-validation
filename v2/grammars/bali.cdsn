
!>
    BALI DOCUMENT NOTATION
    This document is a formal definition of Bali Document Notation™ (Bali) using
    Crater Dog Syntax Notation™ (CDSN).
<!


!>
    TOKEN DEFINITIONS
    The following token definitions are used by the scanner to generate the stream of tokens that
    are processed by the parser.  Each token name begins with an upper case letter.  Unlike with
    rule definitions, a token definition cannot specify the name of a rule but can specify the
    name of another token.  Token definitions cannot be recursive and the scanning of tokens is
    not greedy.  Whitespace within a token definition is not ignored.  The following intrinsic
    token types are environment/language specific, and are not defined in this specification:
     * ANY - any allowed character
     * LOWER_CASE - any allowed lower case character
     * UPPER_CASE - any allowed upper case character
     * DIGIT - any allowed digit
     * SEPARATOR - any allowed character separator
     * ESCAPE - any allowed escape sequence
     * EOL - the environment specific end-of-line sequence
     * EOF - the environment specific end-of-file marker
    The token types are scanned for in the order listed in the specification.
<!

$ANGLE: "~" (ZERO | MAGNITUDE)

$ANY: "any"

$AUTHORITY: +(~("/" | EOL))

$BASE10: '0'..'9'

$BASE16: '0'..'9' | 'a'..'f'

$BASE32: '0'..'9' | 'A'..'D' | 'F'..'H' | 'J'..'N' | 'P'..'T' | 'V'..'Z'

$BASE64: '0'..'9' | 'a'..'z' | 'A'..'Z' | '+' | '/'

$BINARY: "'>" EOL *(*SPACE +BASE64 EOL) *SPACE "<'"

$BOOLEAN: "false" | "true"

$BYTECODE: "'" *(INSTRUCTION *(SPACE INSTRUCTION)) "'"

$CHARACTER: ESCAPE | ~('"' | EOL)

$COMMENT: "!>" EOL *(COMMENT | ~"<!") EOL *SPACE "<!"  ! Allows recursion.

$COMPLEX: "(" (RECTANGULAR | POLAR) ")"

$DAY: '0'..'2' '1'..'9' | '3' '0'..'1'

$DAYS: TIMESPAN "D"

$DELIMITER: "~" | "}" | "|" | "{" | "^" | "]" | "[" | "@" | "?=" | ">" | "=" | "≠" | "<-" | "<" | ";" | ":=" | ":" | "/=" | "//" | "/" | ".." | "." | "-=" | "-" | "," | "+=" | "+" | "*=" | "*" | ")" | "(" | "&" | "NOT" | "AND" | "SANS" | "OR" | "XOR" | "IS" | "MATCHES"

$DURATION: "~" ?SIGN "P" (WEEKS | ?YEARS ?MONTHS ?DAYS ?("T" ?HOURS ?MINUTES ?SECONDS))

$E: "e"

$EXPONENT: "E" ?SIGN ORDINAL

$FLOAT: ?SIGN MAGNITUDE

$FRACTION: "." +BASE10

$FRAGMENT: *(~(">" | EOL))

$HOUR: '0'..'1' '0'..'9' | '2' '0'..'3'

$HOURS: TIMESPAN "H"

$IDENTIFIER: LETTER *(LETTER | DIGIT)

$IMAGINARY: ?SIGN ?MAGNITUDE "i"

$INFINITY: ?SIGN ("infinity" | "∞")

$INSTRUCTION: 4(BASE16)

$KEYWORD: "accept" | "as" | "at" | "break" | "checkout" | "continue" | "discard" | "do" | "each" | "from" | "if" | "in" | "let" | "level" | "loop" | "matching" | "notarize" | "on" | "post" | "publish" | "reject" | "retrieve" | "return" | "save" | "select" | "throw" | "to" | "while" | "with"

$LETTER: LOWER_CASE | UPPER_CASE

$MAGNITUDE: E | PI | PHI | TAU | SCALAR

$MINUTE: '0'..'5' '0'..'9'

$MINUTES: TIMESPAN "M"

$MOMENT: "<" ?SIGN YEAR ?("-" MONTH ?("-" DAY ?("T" HOUR ?(":" MINUTE ?(":" SECOND ?FRACTION))))) ">"

$MONIKER: +("/" NAME)

$MONTH: '0' '1'..'9' | '1' '0'..'2'

$MONTHS: TIMESPAN "M"

$NAME: LETTER *(?SEPARATOR (LETTER | DIGIT))

$NARRATIVE: '"' '>' EOL *(NARRATIVE | ~('<' '"')) EOL *SPACE '<' '"'

$NONE: "none"

$NOTE: "! " *(~EOL)

$NUMBER: REAL | IMAGINARY | COMPLEX

$ONE: "1."

$ORDINAL: '1'..'9' *('0'..'9')

$PATH: *(~("?" | "#" | ">" | EOL))

$PATTERN: NONE | REGEX | ANY

$PERCENTAGE: REAL "%"

$PHI: "phi" | "φ"

$PI: "pi" | "π"

$POLAR: MAGNITUDE "e^" ANGLE "i"

$PROBABILITY: FRACTION | ONE

$QUERY: *(~("#" | ">" | EOL))

$QUOTE: '"' *CHARACTER '"'

$REAL: ZERO | FLOAT | INFINITY | UNDEFINED

$RECTANGULAR: FLOAT ", " FLOAT "i"

$REGEX: '"' +CHARACTER '"' '?'

$RESOURCE: "<" SCHEME ":" ?("//" AUTHORITY) "/" PATH ?("?" QUERY) ?("#" FRAGMENT) ">"

$SCALAR: (ZERO FRACTION | ORDINAL ?FRACTION) ?EXPONENT

$SCHEME: ('a'..'z' | 'A'..'Z') *('0'..'9' | 'a'..'z' | 'A'..'Z' | '+' | '-' | '.')

$SECOND: '0'..'5' '0'..'9' | '6' '0'..'1'

$SECONDS: TIMESPAN "S"

$SIGN: "+" | "-"

$SPACE: " "

$SYMBOL: "$" IDENTIFIER

$TAG: "#" +BASE32

$TAU: "tau" | "τ"

$TIMESPAN: ZERO | ORDINAL ?FRACTION

$UNDEFINED: "undefined"

$UNICODE: "u" 4(BASE16) | "U" 8(BASE16)

$VERSION: "v" ORDINAL *("." ORDINAL)

$WEEKS: TIMESPAN "W"

$YEAR: ZERO | ORDINAL

$YEARS: TIMESPAN "Y"

$ZERO: "0"


!>
    RULE DEFINITIONS
    The following rules are used by the parser when parsing the stream of tokens generated by the
    scanner.  Each rule name begins with a lower case letter.  The rule definitions may specify the
    names of tokens or other rules and are matched by the parser in the order listed.  Rule
    definitions may be recursive.  The sequence of factors within in a rule definition may be
    separated by whitespace which is ignored by the parser.  The starting rule is the $source rule.
<!

$acceptClause: "accept" message

$annotation: NOTE | COMMENT

$arguments: "(" ?(expression *("," expression)) ")"

$arithmetic: expression ("*" | "/" | "//" | "+" | "-") expression

$assignment: letClause  ! ?("let" recipient (":=" | "?=" | "+=" | "-=" | "*=" | "/=")) expression

$association: key ":" value

$associations:
      association *("," association)
    | EOL +(association EOL)
    | ":"  ! No associations.

$attribute: variable indices

$bag: expression

$breakClause: "break" "loop"

$chaining: expression "&" expression

$checkoutClause: "checkout" recipient ?("at" "level" ordinal) "from" moniker

$collection: "[" components | associations "]"

$comparison: expression ("<" | "=" | ">" | "≠" | "IS" | "MATCHES") expression

$complement: "NOT" expression

$component: entity ?context ?NOTE

$components:
      component *("," component)
    | EOL +(component EOL)
    | " "  ! No components.

$composite: expression

$condition: expression

$context: "(" parameters ")"

$continueClause: "continue" "loop"

$control:
      ifClause  ! "if" condition "do" procedure
    | selectClause  ! "select" target +("matching" pattern "do" procedure)
    | whileClause  ! "while" condition "do" procedure
    | withClause  ! "with" "each" item "in" sequence "do" procedure
    | continueClause  ! "continue" "loop"
    | breakClause  ! "break" "loop"
    | returnClause  ! "return" result
    | throwClause  ! "throw" exception

$dereference: "@" expression

$discardClause: "discard" document

$document: expression

$element: ANGLE | BOOLEAN | DURATION | MOMENT | NUMBER | PATTERN | PERCENTAGE | PROBABILITY | RESOURCE

$entity: element | string | range | collection | procedure

$event: expression

$exception: expression

$exponential: expression "^" expression

$expression:
      component  ! entity ?context ?NOTE
    | intrinsic  ! function arguments
    | variable  ! IDENTIFIER
    | precedence  ! "(" expression ")"
    | dereference  ! "@" expression
    | invocation  ! target ("." | "<-") method arguments
    | subcomponent  ! composite indices
    | chaining  ! expression "&" expression
    | exponential  ! expression "^" expression
    | inversion  ! ("-" | "/" | "*") expression
    | arithmetic  ! expression ("*" | "/" | "//" | "+" | "-") expression
    | magnitude  ! "|" expression "|"
    | comparison  ! expression ("<" | "=" | ">" | "≠" | "IS" | "MATCHES") expression
    | complement  ! "NOT" expression
    | logical  ! expression ("AND" | "SANS" | "OR" | "XOR") expression

$failure: SYMBOL

$function: IDENTIFIER

$ifClause: "if" condition "do" procedure

$indices: "[" expression *("," expression) "]"

$intrinsic: function arguments

$inversion: ("-" | "/" | "*") expression

$invocation: target ("." | "<-") method arguments

$item: SYMBOL

$key: primitive

$letClause: ?("let" recipient (":=" | "?=" | "+=" | "-=" | "*=" | "/=")) expression

$logical: expression ("AND" | "SANS" | "OR" | "XOR") expression

$magnitude: "|" expression "|"

$mainClause: control | assignment | messaging | repository

$message: expression

$messaging:
      postClause  ! "post" message "to" bag
    | retrieveClause  ! "retrieve" recipient "from" bag
    | acceptClause  ! "accept" message
    | rejectClause  ! "reject" message
    | publishClause  ! "publish" event

$method: IDENTIFIER

$moniker: expression

$name: SYMBOL

$notarizeClause: "notarize" document "as" moniker

$onClause: "on" failure +("matching" pattern "do" procedure)

$ordinal: expression

$parameter: name ":" value

$parameters:
      parameter *("," parameter)
    | EOL +(parameter EOL)  ! At least one parameter is required.

$pattern: expression

$postClause: "post" message "to" bag

$precedence: "(" expression ")"

$primitive: element | string

$procedure: "{" statements "}"

$publishClause: "publish" event

$range: ("[" | "(") primitive ".." primitive (")" | "]")

$recipient: name | attribute

$rejectClause: "reject" message

$repository:
      checkoutClause  ! "checkout" recipient ?("at" "level" ordinal) "from" moniker
    | saveClause  ! "save" document "as" recipient
    | discardClause  ! "discard" document
    | notarizeClause  ! "notarize" document "as" moniker

$result: expression

$retrieveClause: "retrieve" recipient "from" bag

$returnClause: "return" result

$saveClause: "save" document "as" recipient

$selectClause: "select" target +("matching" pattern "do" procedure)

$sequence: expression

$source: component EOF  ! EOF is the end-of-file marker.

$statement: ?(annotation EOL) mainClause ?onClause ?NOTE

$statements:
      statement *(";" statement)
    | EOL +(?statement EOL)  ! Allows blank lines.
    | " "  ! An empty procedure.

$string: BINARY | BYTECODE | MONIKER | NARRATIVE | QUOTE | SYMBOL | TAG | VERSION

$subcomponent: composite indices

$target: expression

$throwClause: "throw" exception

$value: component

$variable: IDENTIFIER

$whileClause: "while" condition "do" procedure

$withClause: "with" "each" item "in" sequence "do" procedure

