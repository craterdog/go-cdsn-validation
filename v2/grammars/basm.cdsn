
!>
    BALI ASSEMBLY LANGUAGE
    This document contains a formal definition of the Bali Assembly Language™ (BASM) using Crater
    Dog Syntax Notation™ (CDSN).  A language grammar consists of a set of token and rule definitions.
<!


!>
    TOKEN DEFINITIONS
    The following token definitions are used by the scanner to generate the stream of tokens that
    are processed by the parser.  Each token name begins with an upper case letter.  Unlike with
    rule definitions, a token definition cannot specify the name of a rule but can specify the
    name of another token.  Token definitions cannot be recursive and the scanning of tokens is
    not greedy.  Whitespace within a token definition is not ignored.

    The following intrinsic token types are environment or language specific:
     * ANY - any language specific character
     * LOWER_CASE - any language specific lower case character
     * UPPER_CASE - any language specific upper case character
     * DIGIT - any language specific digit
     * ESCAPE - any environment specific escape sequence
     * CONTROL - any environment specific (non-printable) control character
     * EOF - the environment specific end-of-file marker

    Inversion within a token definition may only be applied to a token predicate resulting in a
    single character.  Token inversions cannot be nested.  The following token types are scanned for
    in the order listed below.
<!

$LABEL: (NUMBER '.')+ NAME

$NUMBER: '1'..'9' '0'..'9'*

$LITERAL: "`" ANY* "`"

$SYMBOL: '$' NAME ('-' NUMBER)?

$NOTE: "! " (~CONTROL)*

$NAME: LETTER (LETTER | DIGIT)*

$LETTER: LOWER_CASE | UPPER_CASE


!>
    RULE DEFINITIONS
    The following rules are used by the parser when parsing the stream of tokens generated by the
    scanner.  Each rule name begins with a lower case letter.  The rule definitions may specify the
    names of tokens or other rules and are matched by the parser in the order listed.  A rule
    definition may also be directly or indirectly recursive.  The sequence of factors within
    in a rule definition may be separated by whitespace which is ignored by the parser.

    A predicate within a factor may also be constrained by any of the following cardinalities:
     * predicate{M} - Exactly M instances of the specified predicate.
     * predicate{M..} - M or more instances of the specified predicate.
     * predicate{M..N} - M to N instances of the specified predicate.
     * predicate? - Zero or one instances of the specified predicate (equivalent to predicate{0..1}).
     * predicate* - Zero or more instances of the specified predicate (equivalent to predicate{0..}).
     * predicate+ - One or more instances of the specified predicate (equivalent to predicate{1..}).

    Inversion within a rule definition may only be applied to a token predicate resulting in a
    single token.  Rule inversions cannot be nested.  The following rules are attempted in the order
    listed below.
<!

$document: instructions EOF

$instructions: instruction*

$instruction: label? action

$label: LABEL ":"

$action: note | jump | push | pull | load | save | drop | call | send


!>
    Information only, no action occurs.
<!

$note: "NOTE" NOTE


!>
    Jump to the address at the label if the value on the component stack matches
    the condition. Otherwise, continue execution at the next instruction. If
    there is no condition then jump unconditionally.
<!

$jump: "JUMP" "TO" ("NEXT" "INSTRUCTION" | LABEL ("ON" ("EMPTY" | "NONE" | "FALSE"))?)


!>
    Push a literal component, constant or parameter onto the component stack, or
    push the handler address for the current exception handlers onto the handler
    stack.
<!

$push: "PUSH" ("HANDLER" LABEL | "LITERAL" LITERAL | "CONSTANT" SYMBOL | "ARGUMENT" SYMBOL)


!>
    Pull whatever is currently on top of the handler or component stack off and
    either discard it or use it accordingly.
<!

$pull: "PULL" ("HANDLER" | "COMPONENT" | "RESULT" | "EXCEPTION")


!>
    Load onto the component stack a variable value, document, contract or random
    message from a bag.
<!

$load: "LOAD" ("VARIABLE" | "DOCUMENT" | "CONTRACT" | "MESSAGE") SYMBOL


!>
    Save the top of the component stack to a variable value, document, contract
    or message bag.
<!

$save: "SAVE" ("VARIABLE" | "DOCUMENT" | "CONTRACT" | "MESSAGE") SYMBOL


!>
    Drop a variable value, document, contract or message.
<!

$drop: "DROP" ("VARIABLE" | "DOCUMENT" | "CONTRACT" | "MESSAGE") SYMBOL


!>
    Call the specified intrinsic function using the [0..3] arguments that
    are on the component stack. The resulting value of the invocation
    replaces the arguments that were on the top of the component stack.
<!

$call: "CALL" SYMBOL ("WITH" ("1" "ARGUMENT" | NUMBER "ARGUMENTS"))?


!>
    Send a message with an optional list of arguments to the local component or
    document referenced by the name or citation that is on top of the component
    stack. If the recipient is a document, a new procedure context containing
    the message, arguments, and contract name is placed in a bag to be executed
    by the next available processor. Otherwise, the current processor loads the
    bytecode for the procedure associated with the message defined in the
    local component's type definition into a new procedure context and begins
    executing it using the target component and array of arguments.  When the
    new procedure context completes its execution, the resulting value replaces
    the component and array of arguments that were on the top of the component
    stack.
<!

$send: "SEND" SYMBOL "TO" ("COMPONENT" | "DOCUMENT") ("WITH" "ARGUMENTS")?

